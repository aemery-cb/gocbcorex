// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package core

import (
	"context"
	"github.com/couchbase/gocbcorex/memdx"
	"sync"
)

// Ensure, that KvClientMock does implement KvClient.
// If this is not the case, regenerate this file with moq.
var _ KvClient = &KvClientMock{}

// KvClientMock is a mock implementation of KvClient.
//
//	func TestSomethingThatUsesKvClient(t *testing.T) {
//
//		// make and configure a mocked KvClient
//		mockedKvClient := &KvClientMock{
//			CloseFunc: func() error {
//				panic("mock out the Close method")
//			},
//			DeleteFunc: func(ctx context.Context, req *memdx.DeleteRequest) (*memdx.DeleteResponse, error) {
//				panic("mock out the Delete method")
//			},
//			GetFunc: func(ctx context.Context, req *memdx.GetRequest) (*memdx.GetResponse, error) {
//				panic("mock out the Get method")
//			},
//			GetAndLockFunc: func(ctx context.Context, req *memdx.GetAndLockRequest) (*memdx.GetAndLockResponse, error) {
//				panic("mock out the GetAndLock method")
//			},
//			GetClusterConfigFunc: func(ctx context.Context, req *memdx.GetClusterConfigRequest) ([]byte, error) {
//				panic("mock out the GetClusterConfig method")
//			},
//			GetCollectionIDFunc: func(ctx context.Context, req *memdx.GetCollectionIDRequest) (*memdx.GetCollectionIDResponse, error) {
//				panic("mock out the GetCollectionID method")
//			},
//			LoadFactorFunc: func() float64 {
//				panic("mock out the LoadFactor method")
//			},
//			ReconfigureFunc: func(ctx context.Context, opts *KvClientConfig) error {
//				panic("mock out the Reconfigure method")
//			},
//			SetFunc: func(ctx context.Context, req *memdx.SetRequest) (*memdx.SetResponse, error) {
//				panic("mock out the Set method")
//			},
//		}
//
//		// use mockedKvClient in code that requires KvClient
//		// and then make assertions.
//
//	}
type KvClientMock struct {
	// CloseFunc mocks the Close method.
	CloseFunc func() error

	// DeleteFunc mocks the Delete method.
	DeleteFunc func(ctx context.Context, req *memdx.DeleteRequest) (*memdx.DeleteResponse, error)

	// GetFunc mocks the Get method.
	GetFunc func(ctx context.Context, req *memdx.GetRequest) (*memdx.GetResponse, error)

	// GetAndLockFunc mocks the GetAndLock method.
	GetAndLockFunc func(ctx context.Context, req *memdx.GetAndLockRequest) (*memdx.GetAndLockResponse, error)

	// GetClusterConfigFunc mocks the GetClusterConfig method.
	GetClusterConfigFunc func(ctx context.Context, req *memdx.GetClusterConfigRequest) ([]byte, error)

	// GetCollectionIDFunc mocks the GetCollectionID method.
	GetCollectionIDFunc func(ctx context.Context, req *memdx.GetCollectionIDRequest) (*memdx.GetCollectionIDResponse, error)

	// LoadFactorFunc mocks the LoadFactor method.
	LoadFactorFunc func() float64

	// ReconfigureFunc mocks the Reconfigure method.
	ReconfigureFunc func(ctx context.Context, opts *KvClientConfig) error

	// SetFunc mocks the Set method.
	SetFunc func(ctx context.Context, req *memdx.SetRequest) (*memdx.SetResponse, error)

	// calls tracks calls to the methods.
	calls struct {
		// Close holds details about calls to the Close method.
		Close []struct {
		}
		// Delete holds details about calls to the Delete method.
		Delete []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *memdx.DeleteRequest
		}
		// Get holds details about calls to the Get method.
		Get []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *memdx.GetRequest
		}
		// GetAndLock holds details about calls to the GetAndLock method.
		GetAndLock []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *memdx.GetAndLockRequest
		}
		// GetClusterConfig holds details about calls to the GetClusterConfig method.
		GetClusterConfig []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *memdx.GetClusterConfigRequest
		}
		// GetCollectionID holds details about calls to the GetCollectionID method.
		GetCollectionID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *memdx.GetCollectionIDRequest
		}
		// LoadFactor holds details about calls to the LoadFactor method.
		LoadFactor []struct {
		}
		// Reconfigure holds details about calls to the Reconfigure method.
		Reconfigure []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Opts is the opts argument value.
			Opts *KvClientConfig
		}
		// Set holds details about calls to the Set method.
		Set []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *memdx.SetRequest
		}
	}
	lockClose            sync.RWMutex
	lockDelete           sync.RWMutex
	lockGet              sync.RWMutex
	lockGetAndLock       sync.RWMutex
	lockGetClusterConfig sync.RWMutex
	lockGetCollectionID  sync.RWMutex
	lockLoadFactor       sync.RWMutex
	lockReconfigure      sync.RWMutex
	lockSet              sync.RWMutex
}

// Close calls CloseFunc.
func (mock *KvClientMock) Close() error {
	if mock.CloseFunc == nil {
		panic("KvClientMock.CloseFunc: method is nil but KvClient.Close was just called")
	}
	callInfo := struct {
	}{}
	mock.lockClose.Lock()
	mock.calls.Close = append(mock.calls.Close, callInfo)
	mock.lockClose.Unlock()
	return mock.CloseFunc()
}

// CloseCalls gets all the calls that were made to Close.
// Check the length with:
//
//	len(mockedKvClient.CloseCalls())
func (mock *KvClientMock) CloseCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockClose.RLock()
	calls = mock.calls.Close
	mock.lockClose.RUnlock()
	return calls
}

// Delete calls DeleteFunc.
func (mock *KvClientMock) Delete(ctx context.Context, req *memdx.DeleteRequest) (*memdx.DeleteResponse, error) {
	if mock.DeleteFunc == nil {
		panic("KvClientMock.DeleteFunc: method is nil but KvClient.Delete was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *memdx.DeleteRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockDelete.Lock()
	mock.calls.Delete = append(mock.calls.Delete, callInfo)
	mock.lockDelete.Unlock()
	return mock.DeleteFunc(ctx, req)
}

// DeleteCalls gets all the calls that were made to Delete.
// Check the length with:
//
//	len(mockedKvClient.DeleteCalls())
func (mock *KvClientMock) DeleteCalls() []struct {
	Ctx context.Context
	Req *memdx.DeleteRequest
} {
	var calls []struct {
		Ctx context.Context
		Req *memdx.DeleteRequest
	}
	mock.lockDelete.RLock()
	calls = mock.calls.Delete
	mock.lockDelete.RUnlock()
	return calls
}

// Get calls GetFunc.
func (mock *KvClientMock) Get(ctx context.Context, req *memdx.GetRequest) (*memdx.GetResponse, error) {
	if mock.GetFunc == nil {
		panic("KvClientMock.GetFunc: method is nil but KvClient.Get was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *memdx.GetRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc(ctx, req)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedKvClient.GetCalls())
func (mock *KvClientMock) GetCalls() []struct {
	Ctx context.Context
	Req *memdx.GetRequest
} {
	var calls []struct {
		Ctx context.Context
		Req *memdx.GetRequest
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// GetAndLock calls GetAndLockFunc.
func (mock *KvClientMock) GetAndLock(ctx context.Context, req *memdx.GetAndLockRequest) (*memdx.GetAndLockResponse, error) {
	if mock.GetAndLockFunc == nil {
		panic("KvClientMock.GetAndLockFunc: method is nil but KvClient.GetAndLock was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *memdx.GetAndLockRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockGetAndLock.Lock()
	mock.calls.GetAndLock = append(mock.calls.GetAndLock, callInfo)
	mock.lockGetAndLock.Unlock()
	return mock.GetAndLockFunc(ctx, req)
}

// GetAndLockCalls gets all the calls that were made to GetAndLock.
// Check the length with:
//
//	len(mockedKvClient.GetAndLockCalls())
func (mock *KvClientMock) GetAndLockCalls() []struct {
	Ctx context.Context
	Req *memdx.GetAndLockRequest
} {
	var calls []struct {
		Ctx context.Context
		Req *memdx.GetAndLockRequest
	}
	mock.lockGetAndLock.RLock()
	calls = mock.calls.GetAndLock
	mock.lockGetAndLock.RUnlock()
	return calls
}

// GetClusterConfig calls GetClusterConfigFunc.
func (mock *KvClientMock) GetClusterConfig(ctx context.Context, req *memdx.GetClusterConfigRequest) ([]byte, error) {
	if mock.GetClusterConfigFunc == nil {
		panic("KvClientMock.GetClusterConfigFunc: method is nil but KvClient.GetClusterConfig was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *memdx.GetClusterConfigRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockGetClusterConfig.Lock()
	mock.calls.GetClusterConfig = append(mock.calls.GetClusterConfig, callInfo)
	mock.lockGetClusterConfig.Unlock()
	return mock.GetClusterConfigFunc(ctx, req)
}

// GetClusterConfigCalls gets all the calls that were made to GetClusterConfig.
// Check the length with:
//
//	len(mockedKvClient.GetClusterConfigCalls())
func (mock *KvClientMock) GetClusterConfigCalls() []struct {
	Ctx context.Context
	Req *memdx.GetClusterConfigRequest
} {
	var calls []struct {
		Ctx context.Context
		Req *memdx.GetClusterConfigRequest
	}
	mock.lockGetClusterConfig.RLock()
	calls = mock.calls.GetClusterConfig
	mock.lockGetClusterConfig.RUnlock()
	return calls
}

// GetCollectionID calls GetCollectionIDFunc.
func (mock *KvClientMock) GetCollectionID(ctx context.Context, req *memdx.GetCollectionIDRequest) (*memdx.GetCollectionIDResponse, error) {
	if mock.GetCollectionIDFunc == nil {
		panic("KvClientMock.GetCollectionIDFunc: method is nil but KvClient.GetCollectionID was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *memdx.GetCollectionIDRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockGetCollectionID.Lock()
	mock.calls.GetCollectionID = append(mock.calls.GetCollectionID, callInfo)
	mock.lockGetCollectionID.Unlock()
	return mock.GetCollectionIDFunc(ctx, req)
}

// GetCollectionIDCalls gets all the calls that were made to GetCollectionID.
// Check the length with:
//
//	len(mockedKvClient.GetCollectionIDCalls())
func (mock *KvClientMock) GetCollectionIDCalls() []struct {
	Ctx context.Context
	Req *memdx.GetCollectionIDRequest
} {
	var calls []struct {
		Ctx context.Context
		Req *memdx.GetCollectionIDRequest
	}
	mock.lockGetCollectionID.RLock()
	calls = mock.calls.GetCollectionID
	mock.lockGetCollectionID.RUnlock()
	return calls
}

// LoadFactor calls LoadFactorFunc.
func (mock *KvClientMock) LoadFactor() float64 {
	if mock.LoadFactorFunc == nil {
		panic("KvClientMock.LoadFactorFunc: method is nil but KvClient.LoadFactor was just called")
	}
	callInfo := struct {
	}{}
	mock.lockLoadFactor.Lock()
	mock.calls.LoadFactor = append(mock.calls.LoadFactor, callInfo)
	mock.lockLoadFactor.Unlock()
	return mock.LoadFactorFunc()
}

// LoadFactorCalls gets all the calls that were made to LoadFactor.
// Check the length with:
//
//	len(mockedKvClient.LoadFactorCalls())
func (mock *KvClientMock) LoadFactorCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockLoadFactor.RLock()
	calls = mock.calls.LoadFactor
	mock.lockLoadFactor.RUnlock()
	return calls
}

// Reconfigure calls ReconfigureFunc.
func (mock *KvClientMock) Reconfigure(ctx context.Context, opts *KvClientConfig) error {
	if mock.ReconfigureFunc == nil {
		panic("KvClientMock.ReconfigureFunc: method is nil but KvClient.Reconfigure was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Opts *KvClientConfig
	}{
		Ctx:  ctx,
		Opts: opts,
	}
	mock.lockReconfigure.Lock()
	mock.calls.Reconfigure = append(mock.calls.Reconfigure, callInfo)
	mock.lockReconfigure.Unlock()
	return mock.ReconfigureFunc(ctx, opts)
}

// ReconfigureCalls gets all the calls that were made to Reconfigure.
// Check the length with:
//
//	len(mockedKvClient.ReconfigureCalls())
func (mock *KvClientMock) ReconfigureCalls() []struct {
	Ctx  context.Context
	Opts *KvClientConfig
} {
	var calls []struct {
		Ctx  context.Context
		Opts *KvClientConfig
	}
	mock.lockReconfigure.RLock()
	calls = mock.calls.Reconfigure
	mock.lockReconfigure.RUnlock()
	return calls
}

// Set calls SetFunc.
func (mock *KvClientMock) Set(ctx context.Context, req *memdx.SetRequest) (*memdx.SetResponse, error) {
	if mock.SetFunc == nil {
		panic("KvClientMock.SetFunc: method is nil but KvClient.Set was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *memdx.SetRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockSet.Lock()
	mock.calls.Set = append(mock.calls.Set, callInfo)
	mock.lockSet.Unlock()
	return mock.SetFunc(ctx, req)
}

// SetCalls gets all the calls that were made to Set.
// Check the length with:
//
//	len(mockedKvClient.SetCalls())
func (mock *KvClientMock) SetCalls() []struct {
	Ctx context.Context
	Req *memdx.SetRequest
} {
	var calls []struct {
		Ctx context.Context
		Req *memdx.SetRequest
	}
	mock.lockSet.RLock()
	calls = mock.calls.Set
	mock.lockSet.RUnlock()
	return calls
}

// Ensure, that MemdxDispatcherCloserMock does implement MemdxDispatcherCloser.
// If this is not the case, regenerate this file with moq.
var _ MemdxDispatcherCloser = &MemdxDispatcherCloserMock{}

// MemdxDispatcherCloserMock is a mock implementation of MemdxDispatcherCloser.
//
//	func TestSomethingThatUsesMemdxDispatcherCloser(t *testing.T) {
//
//		// make and configure a mocked MemdxDispatcherCloser
//		mockedMemdxDispatcherCloser := &MemdxDispatcherCloserMock{
//			CloseFunc: func() error {
//				panic("mock out the Close method")
//			},
//			DispatchFunc: func(packet *memdx.Packet, dispatchCallback memdx.DispatchCallback) (memdx.PendingOp, error) {
//				panic("mock out the Dispatch method")
//			},
//		}
//
//		// use mockedMemdxDispatcherCloser in code that requires MemdxDispatcherCloser
//		// and then make assertions.
//
//	}
type MemdxDispatcherCloserMock struct {
	// CloseFunc mocks the Close method.
	CloseFunc func() error

	// DispatchFunc mocks the Dispatch method.
	DispatchFunc func(packet *memdx.Packet, dispatchCallback memdx.DispatchCallback) (memdx.PendingOp, error)

	// calls tracks calls to the methods.
	calls struct {
		// Close holds details about calls to the Close method.
		Close []struct {
		}
		// Dispatch holds details about calls to the Dispatch method.
		Dispatch []struct {
			// Packet is the packet argument value.
			Packet *memdx.Packet
			// DispatchCallback is the dispatchCallback argument value.
			DispatchCallback memdx.DispatchCallback
		}
	}
	lockClose    sync.RWMutex
	lockDispatch sync.RWMutex
}

// Close calls CloseFunc.
func (mock *MemdxDispatcherCloserMock) Close() error {
	if mock.CloseFunc == nil {
		panic("MemdxDispatcherCloserMock.CloseFunc: method is nil but MemdxDispatcherCloser.Close was just called")
	}
	callInfo := struct {
	}{}
	mock.lockClose.Lock()
	mock.calls.Close = append(mock.calls.Close, callInfo)
	mock.lockClose.Unlock()
	return mock.CloseFunc()
}

// CloseCalls gets all the calls that were made to Close.
// Check the length with:
//
//	len(mockedMemdxDispatcherCloser.CloseCalls())
func (mock *MemdxDispatcherCloserMock) CloseCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockClose.RLock()
	calls = mock.calls.Close
	mock.lockClose.RUnlock()
	return calls
}

// Dispatch calls DispatchFunc.
func (mock *MemdxDispatcherCloserMock) Dispatch(packet *memdx.Packet, dispatchCallback memdx.DispatchCallback) (memdx.PendingOp, error) {
	if mock.DispatchFunc == nil {
		panic("MemdxDispatcherCloserMock.DispatchFunc: method is nil but MemdxDispatcherCloser.Dispatch was just called")
	}
	callInfo := struct {
		Packet           *memdx.Packet
		DispatchCallback memdx.DispatchCallback
	}{
		Packet:           packet,
		DispatchCallback: dispatchCallback,
	}
	mock.lockDispatch.Lock()
	mock.calls.Dispatch = append(mock.calls.Dispatch, callInfo)
	mock.lockDispatch.Unlock()
	return mock.DispatchFunc(packet, dispatchCallback)
}

// DispatchCalls gets all the calls that were made to Dispatch.
// Check the length with:
//
//	len(mockedMemdxDispatcherCloser.DispatchCalls())
func (mock *MemdxDispatcherCloserMock) DispatchCalls() []struct {
	Packet           *memdx.Packet
	DispatchCallback memdx.DispatchCallback
} {
	var calls []struct {
		Packet           *memdx.Packet
		DispatchCallback memdx.DispatchCallback
	}
	mock.lockDispatch.RLock()
	calls = mock.calls.Dispatch
	mock.lockDispatch.RUnlock()
	return calls
}
